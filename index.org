#+title: Summer Roguelike project
#+date: <2023-06-26 Mon>
#+options: toc:nil

Each summer r/roguelikedev has a [[https://old.reddit.com/r/roguelikedev/wiki/python_tutorial_series][summer event]] in which we all make a simple roguelike, roughly following the libtcod roguelike tutorial. [[href:/x/2226-roguelike-dev/][Last year I tried to clone Dwarf Fortress]] in 40 hours. That was too ambitious. But I did enjoy working on a "fortress mode" project more than an "adventure mode" project, so I'd like to do something like that this year, but with a smaller scope.

#+include: "game.html" export html

Icons from [[https://game-icons.net][game-icons.net]], CC BY 3.0. Code repository [[https://github.com/redblobgames/2327-roguelikedev][on github]].

#+TOC: headlines 2

Unlike a typical "fortress mode" game, I want to have an end to the game. This is inspired by Against the Storm, which lets you build a town but then you win or lose, and you start another town. But I don't really know how to do this right now, so I'm going to go ahead and implement parts of the game and hope to figure it out later.

The main idea right now is that the wilderness is all accessible at the beginning.  You can use natural resources at small scales. But to advance, you need to set up rooms to refine and process resources. Last year, building rooms and walls tile by tile is what doomed my project. This year, all the rooms will already exist in the dungeon. You'll claim and populate them.

* Setting up
:PROPERTIES:
:UNNUMBERED: t
:SECTION_NUMBER: 0
:CUSTOM_ID: setting-up
:END:

Since I'm participating in the Roguelikedev summer event, I'm going to /try/ to follow the same section numbers as the original Python tutorial, even though it's an "adventure mode" game and I'm not making a game like that.

Last year I said I feel like a JavaScript project is easier to set up than a Python project, and I continue to feel that way. I did use a build step last year, but it's not necessary to do that, and most of my projects don't use a build step. This year I'm going to start out without a build step, and only add one if I need to.

* Moving around
:PROPERTIES:
:CUSTOM_ID: moving-around
:END:

Last year I was trying to make a Factorio-like interface where you walk around with a character using your keyboard, even though you're building a base. I decided that it didn't work well. So this year I'm going to try a more conventional mouse-based map scrolling interface. Left mouse drag will scroll the map.

#+begin_export html
<figure>
<img src="blog/1-scrolling-screenshot.png" alt="Screenshot of game map" />
<figcaption>Part 1: scrollable map</figcaption>
</figure>
#+end_export

I used the drag code from [[href:/making-of/draggable/][my draggable object guide]] to move the /camera/ position. But how do I calculate the view from that? The view is a rectangle centered on the camera position.

#+begin_export html
<figure>
<img src="blog/1-scrolling-view.png" alt="Diagram showing the scrollable view area" />
<figcaption>Scrolling calculation: view box</figcaption>
</figure>
#+end_export

The top left of that rectangle is the /offset/ for drawing to the screen. To find the top left, I take the camera position and subtract /half/ the view box size. Then I take the world coordinates of whatever I'm drawing and /subtract/ the offset to the top left corner. If the object is at (50, 35) in the world, and the top left corner of the view box is at (50, 35), then I want to draw the object at (0, 0) on the screen.

#+begin_export html
<figure>
<img src="blog/1-scrolling-offset.png" alt="Diagram showing the offset calculation" />
<figcaption>Scrolling calculation: offset</figcaption>
</figure>
#+end_export

The second thing I wanted to do here was to /constrain/ the camera position to places where the map would be in view. Think about where the view box can be, and then where the camera position can be:

#+begin_export html
<figure>
<img src="blog/1-scrolling-camera-positions.png" alt="Diagram showing where the camera can be placed" />
<figcaption>Scrolling calculation: camera position</figcaption>
</figure>
#+end_export

The camera's position is restricted to a rectangle the size of the map, but shrunk by a /half view box/ at each corner. This will keep the view inside the map region. A little detail: I added a slight margin to this calculation so that you can go outside the map region just a tiny bit. This adds a visual border to show that you're at the edge of the map.

For the other controls, I want to try making something trackpad friendly, requiring only the left button, but then using /keys/ to modify the mouse action. For example, instead of clicking through a menu to select "storage area" and then going into a "storage area marking mode", I might try “hold down ~S~ while dragging a rectangle". This wouldn't require navigating menus. The mode is activated while you hold down the key and the rectangle ends when you release the key. I don't know whether I'll like this until I try it.

* Entity, render, map
:PROPERTIES:
:CUSTOM_ID: entity-render-map
:END:

I did Part 3 (generating a map) first, and then came back to Part 2 (rendering that map, and entities).

Last year, pathfinding turned out to be tricky. Colonists could be building a wall that blocks another colonist's movement. To reduce the scope of the game, I'm going to try simplifying the pathfinding requirements.

1. The player won't dig out rooms or build walls. The rooms already exist in the map, and are unlocked.
2. Pathfinding from room to room can be cheap and precalculated. These paths funnel through the doors.
3. Pathfinding /within/ a room is still tricky, because I want the player to build objects within the room, and those objects would block paths. I need to prohibit building an object that blocks paths across the room. Or … I can let colonists walk over anything, but assign a higher movement cost to them so that they prefer to walk in open areas.
4. Colonists can pass through each other. This simplifies the pathfinding obstacle management. The only obstacles are static objects within rooms.

So I implemented pathfinding, using breadth first search for now, but can switch to A* later. I put 25 colonists into the world and told them to find paths to random locations, then walk there. When they have finished walking, they find another path. This tests the pathfinding system before I have jobs for the colonists.

#+begin_export html
<figure>
  <img src="blog/2-pathfinding-entities.png" alt="Screenshot of colonists in the world" />
  <figcaption>Colonists walking around randomly</figcaption>
</figure>
#+end_export

A side note: Python is /so wonderful/ in how it allows tuples to be used in so many places, including keys for dicts. In JavaScript, an Object can have string keys, and a Map can have object keys, but there's nothing convenient like Python's tuples for storing ~(x, y)~ pairs. C++ and Rust have the convenient tuples too. I miss this when working in JavaScript, and hope that one day [[https://tc39.es/proposal-record-tuple/tutorial/][they get added]], but there seems to be no progress on that proposal.

* Generating a map
:PROPERTIES:
:CUSTOM_ID: generating-a-map
:END:

I liked the left/right nature of the map last year, and I want to do that again. I'll put the wilderness on the left and the dungeon rooms on the right. I reserved the left side of the map for water, then wilderness. Then the rooms begin.

The dungeon rooms will come from the [[href:/x/2321-offgrid/][offgrid algorithm]] that Chris Cox sent me. It's only 20 lines of code. Last year I used thin walls. I think they were neat, especially helping with player-built rooms. I don't have player-built rooms this year. I'll go back to thick walls. Using the offgrid algorithm, I'll generate =left=, =right=, =top=, =bottom= for each room. These are half-open intervals, so ~left <= x < right~ and ~top <= y < bottom~. But I also need to reserve one tile for the thick walls, so I'll use ~left < x < right~ and ~top < y < bottom~.

#+begin_export html
<figure>
  <img src="blog/3-offgrid-map.png" alt="Screenshot" />
  <figcaption>Generated map with water and land on the left, dungeon on the right</figcaption>
</figure>
#+end_export

The next step was to place the walls. There are two parts to this:

1. All tiles within a room are walkable.
2. All tiles to the /left/ of the leftmost room are walkable. This handles the wilderness areas.
3. If there's no leftmost room on a row, use a default border between wilderness and mountain.

The next step after that is doors. I had [[href:/x/1939-planetary-dungeon/#doors][previously written a door algorithm]] that looks at all tiles that have two adjacent room tiles and two adjacent wall tiles. That algorithm would work here. But I can use something similar. Since my rooms are generated from a grid (using the offgrid algorithm), I can use that original grid to find adjacent rooms. For each room, I pick a random tile on the west wall for a door, and I pick a random tile on the north wall for a door, unless the room is in the topmost row. This produces plenty of connectivity, perhaps too much for a traditional adventure mode dungeon, but probably just fine for a colony simulator:

#+begin_export html
<figure>
  <img src="blog/3-map-with-doors.png" alt="Screenshot showing door placement" />
  <figcaption>Generated map doors between rooms, and doors on the left</figcaption>
</figure>
#+end_export

This produces a way to go from the wilderness into the dungeon, and a way to go from dungeon rooms to adjacent rooms.

* Field of view
:PROPERTIES:
:CUSTOM_ID: field-of-view
:END:

The original tutorial calculates which /tiles/ are visible to the player. For this colonist style game I want to compute which /rooms/ and /doors/ are visible to the player. Last year I made everything visible, so I skipped this part. This year, I want the player to unlock rooms as you go through the game, so those rooms won't be visible until you open them up. Here are the visibility rules I came up with:

1. The player can view the wilderness.
1. The player can view unlocked (colonized) rooms.
1. The player can view the outline but not the interior of unlockable rooms.
1. The player cannot view locked rooms that aren't currently unlockable.
1. Unlockable rooms are currently locked and connected to an unlocked room.
1. There can be at most 3 unlockable rooms at a time. I'm hoping to get a "pick one of these 3 cards" vibe here.
1. Once a room is unlocked, it stays unlocked.
1. A door is visible if either of the rooms it is connected to are visible.

Separate from room lock/unlock status, I'm maintaining a ~walkable~ set of tiles. I decided the easiest thing to do was:

1. The ~walkable~ set starts out as the wilderness area, and doors into the wilderness area.
1. Unlocking a room adds the room's tiles and doors to ~walkable~.

#+begin_export html
<figure>
  <img src="blog/4-locked-rooms.png" alt="Screenshot" />
  <figcaption>Some rooms are locked</figcaption>
</figure>
#+end_export

At some point, unlocking rooms will require resources. For now, I will make it free. I need a UI to unlock rooms. Part 7 in the original tutorial was about interface, so I'm going to work on that now.

* Interface (Part 7)
:PROPERTIES:
:CUSTOM_ID: interface
:END:

This was the topic of Part 7 in the original tutorial.  I think UI needs to come earlier in a management game like this.

I spent a lot of time [[href:/x/2226-roguelike-dev/#section-7][last year]] looking at other games. One of the biggest problems I see in colony games is that it's hard to understand what's going on and what to do to fix problems. The interface is a big part of that. I am hoping that the focus on room-by-room building rather than tile-by-tile building will let me make the information display less granular. I might also be able to make some decisions more explicit. For example, instead of "workshop output is taken to the nearest stockpile" as a /tile by tile/ decision, I could ask the player to designated a /room's output/ as being another /room/. Then the information display can be a giant arrow from one room to another.

I'm going to try a UI where you hold down a /modifier key/ to change what the mouse does. Hold down ~R~ to activate room mode, and then click on a room to unlock it. I need to have a mouse click handler that checks for clickable rooms. And I need to have the mouse pointer change when moving over a clickable object. The click handler should take precedence over map dragging.

I decided I would have a /UI mode/ that controls how to render and how to interpret mouse events. The key state controls which UI mode I'm in. However, as usual, this simple model didn't quite work cleanly. There were things I needed to deal with like: when pressing  ~R~, I want to highlight the room under the mouse pointer, but the =keydown= event doesn't include the mouse position. That means I need to be storing the mouse position always, even before I need it. Another case is that when pressing ~R~ then ~Shift~ then releasing ~R~, the =keydown= event tells me ='r'= was pressed but the =keyup= event tells me ='R'= was released. There are some edge cases I'm just not going to deal with for this project, but I want to keep it in mind for future projects.

Not all rooms are unlockable. Rooms must be /connected/ to an already unlocked room. The way my data structures are written, the easiest way to calculate this was to look at all the doors. A door connecting an unlocked room to a locked room means that locked room is unlockable.

#+begin_export html
<figure>
  <img src="blog/4-unlockable-rooms.png" alt="Screenshot of unlockable rooms" />
  <figcaption>Only some locked rooms are unlockable</figcaption>
</figure>
#+end_export

I also want rooms to have labels. I think in a management game it's important to see the "big picture", and I think labels can help. I need to size the labels so that they fit. I used the [[https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics][TextMetrics]] feature to resize them:

#+begin_export html
<figure>
  <img src="blog/4-room-labels.png" alt="Screenshot of room labels" />
  <figcaption>Rooms have labels, sized to fit</figcaption>
</figure>
#+end_export

The room labels will be "Kitchen", "Dining", "Bedroom", etc. but I haven't implemented room types yet.

Bug: I noticed that on Firefox/Mac, holding down a key causes the cursor to mostly disappear. Weird. This is not only on my site, but on any site.

* Placing enemies (Part 5)
:PROPERTIES:
:CUSTOM_ID: placing-enemies
:END:

Instead of enemies, I have lots of friendly colonist NPCs. They need to have motivations, jobs, inventory, pathfinding, etc.

I want to place furniture objects within rooms.  These objects will correspond to the use of the room. For example, a bedroom's furniture will be beds.

#+begin_export html
<figure>
  <img src="blog/5-room-types.png" alt="Screenshot" />
  <figcaption>Needed to assign room types before implementing furniture</figcaption>
</figure>
#+end_export

Should I make colonists build the furniture, or should they be built immediately? I think immediate is easier to implement, but building furniture is a great activity for colonists. Given how this project is too ambitious already, I will do the simpler thing.

I had been imagining each furniture would have one tile per input, and one tile per output. The room would have an input storage zone and an output storage zone. Colonists would move items from the input zone to the furniture, and when the furniture has all its inputs filled, a colonist can do that job, filling the furniture's output zone. Then there'd be a job to move items from the furniture to the room's output zone. But I wrote all of this out on paper and decided it needed to be simpler.

So the next plan was for each furniture to have one tile per input, one tile to stand on, and one tile for the sprite. I dropped the furniture's output; I can reserve a spot in the room's output zone (but this means I need to implement a tile reservation system, so it's not clear this is actually simpler). I also dropped the room's input zone. Colonists can take items directly to the furniture's input zone instead of first buffering them in the room. These are /imagined/ simplifications. I don't know if it will make the job system more complex. But I'll try it and see.

I also considered simplifying furthur by having furniture be a single tile, with no tile to stand on and no input tiles. But I imagined what that did to the job system, and I didn't like what my imagination told me. So I'm going to try implementing multi-tile furniture (one tile for the sprite and several tiles reserved for items or colonists).

#+begin_export html
<figure>
  <img src="blog/5-furniture.png" alt="Screenshot" />
  <figcaption>Furniture in a room</figcaption>
</figure>
#+end_export

Possible room types and their object types:

| room             | object         | inputs            | outputs     |
|------------------+----------------+-------------------+-------------|
| wilderness*      | berry          | -                 | food        |
| wilderness*      | tree           | -                 | wood        |
| underground farm | -              | -                 | crops       |
| mushroom cavern  | -              | -                 | crops       |
| kitchen          | cooking table  | raw food          | cooked food |
| dining           | dining table   | cooked food       | -           |
| bedroom          | bed            | -                 | -           |
| iron mine        | mining pit     | -                 | iron        |
| quarry           | mining pit     | -                 | stone       |
| crafting         | crafting table | wood, stone, iron | crafts      |

I don't know what the "end game" of the production tree will be, but I think /crafts/ could be the cost of opening up later rooms.

I'd also like to have some room unlocks carry bonuses or penalties, like "workahol fountain — your colonists no longer sleep" or "teleporter accident — you double the number of colonists but they work half as hard".

* Combat (Part 6)
:PROPERTIES:
:CUSTOM_ID: combat
:END:

I had considered having a simplified combat as part of the cost of opening up a new room. You'd have to decide how many colonists to send into a new room to defeat the monsters. Send too few, and you might not get the room. What is the downside of sending too many? Maybe they have to rest for a time afterwards, so that reduces your productivity. Is this at all an interesting/fun decision to make? Not sure.

Another option would be to go the Dungeon Keeper or Tower Defense route, where you have to deal with enemies trickling in. As much as I'd love to make a Dungeon Keeper style game, I think I don't even know how to do the basics so that's something to tackle in a future project.

In the interests of simplicity, I've decided not to have any combat. I can come back and add it later if I have time. But I am pretty sure I won't have extra time.

* Items and inventory (Part 8)
:PROPERTIES:
:CUSTOM_ID: items-and-inventory
:END:

Items are generated by resource objects, stored in stockpiles, and transformed by workshop objects.

A /transport/ job asks a colonist to take an item from one place to another. But why? Each room needs to generate "demand" for some items, and also "supply" from production. Some rooms like mushroom farms will generate supply over time. Other rooms like crafting will generate supply only when a colonist is working there. Maybe I can unify these two types somehow.

A /production/ job asks a colonists to go to a room and transform some input to some output. The input or output might be empty — for example, in the dining room, the input is food and the output is empty. But that should affect the colonist's hunger level, so I need to track that somewhere and also make it visible somehow. And the colonist shouldn't be asked to do the job unless their internal hunger level is low. Hm. So this means colonists need internal stats.

Let's take an axe-making room as an example:

#+begin_src json
tool_shop: {
    furnitureShape: {
        ticks: 60,
        stand: Pos(0, 1),
        inputs: [
            {type: 'iron', pos: Pos(-1, 0)},
            {type: 'wood', pos: Pos(0, -1)},
        ],
        output: 'axe',
        sprites: [{type: 'table', pos: Pos(0, 0)}],
    },
}
#+end_src

- =iron= should be placed 1 west of the table (transport job)
- =wood= should be placed 1 north of the table (transport job)
- there should be one tile free in the output zone

If these are true, then the output zone tile is reserved for this job, and the production job is enabled. A colonist that has no job currently (and is therefore carrying nothing) can take this production job by moving into the =stand= position 1 south of the table. The colonist will stand there for =60= ticks. The =iron= and =wood= will be consumed, and the colonist will be left holding an =axe=, which needs to be placed in the reserved output zone tile. That tile reservation is freed. And the colonist is now free to take on another job.

* Ranged scrolls and targeting (Part 9)
:PROPERTIES:
:CUSTOM_ID: ranged-scrolls-and-targeting
:END:

I don't have ranged scrolls but I expect to have multiple types of building UIs. In particular, I need to add a UI for rectangular zones. My initial thought was that you will press the key on the top left corner, move the mouse, release the key. But a more conventional UI would be to use the mouse button to mark a rectangle.

* Saving and loading (Part 10)
:PROPERTIES:
:CUSTOM_ID: saving-and-loading
:END:

I'm not going to attempt this. I think it's great to have, but it's not important to me right now.

* Dungeon levels (Part 11)
:PROPERTIES:
:CUSTOM_ID: dungeon-levels
:END:

In an adventure style game, each dungeon level is standalone, and they increase in difficulty as you progress. In Dwarf Fortress, the levels aren't standalone, but they do increase in difficulty as you dig deeper. But in this game I don't have dungeon levels. Instead, each /room/ could be thought of as a miniature level to conquer.

* Increasing difficulty (Part 12)
:PROPERTIES:
:CUSTOM_ID: increasing-difficulty
:END:

In a normal adventure mode roguelike, difficulty increases as you go /down/ into the dungeon. In this game, I'd like to have the difficulty increase as you go /right/ (east) into the mountain.

* Gearing up (Part 13)
:PROPERTIES:
:CUSTOM_ID: gearing-up
:END:

As much as it might be fun to have gear for the colonists, I am going to skip this. I need to keep the scope down.

* Conclusion
:PROPERTIES:
:UNNUMBERED: t
:CUSTOM_ID: conclusion
:END:

-

#+begin_export html
<x:footer>
  Created 26 Jun 2023; &#160;
  <!-- hhmts start -->Last modified: 03 Aug 2023<!-- hhmts end -->
</x:footer>
#+end_export
