#+title: Summer Roguelike project
#+date: <2023-06-26 Mon>
#+options: toc:nil

Each summer r/roguelikedev has a [[https://old.reddit.com/r/roguelikedev/wiki/python_tutorial_series][summer event]] in which we all make a simple roguelike, roughly following the libtcod roguelike tutorial. [[href:/x/2226-roguelike-dev/][Last year I tried to clone Dwarf Fortress]] in 40 hours. That was too ambitious. But I did enjoy working on a "fortress mode" project more than an "adventure mode" project, so I'd like to do something like that this year, but with a smaller scope.

#+include: "game.html" export html

Icons from [[https://game-icons.net][game-icons.net]], CC BY 3.0. Code repository [[https://github.com/redblobgames/2327-roguelikedev][on github]].

#+TOC: headlines 2

Unlike a typical "fortress mode" game, I want to have an end to the game. This is inspired by Against the Storm, which lets you build a town but then you win or lose, and you start another town. But I don't really know how to do this right now, so I'm going to go ahead and implement parts of the game and hope to figure it out later.

The main idea right now is that the wilderness is all accessible at the beginning.  You can use natural resources at small scales. But to advance, you need to set up rooms to refine and process resources. Last year, building rooms and walls tile by tile is what doomed my project. This year, all the rooms will already exist in the dungeon. You'll claim and populate them.

* Setting up
:PROPERTIES:
:UNNUMBERED: t
:SECTION_NUMBER: 0
:CUSTOM_ID: setting-up
:END:

Since I'm participating in the Roguelikedev summer event, I'm going to /try/ to follow the same section numbers as the original Python tutorial, even though it's an "adventure mode" game and I'm not making a game like that.

Last year I said I feel like a JavaScript project is easier to set up than a Python project, and I continue to feel that way. I did use a build step last year, but it's not necessary to do that, and most of my projects don't use a build step. This year I'm going to start out without a build step, and only add one if I need to.

* Moving around
:PROPERTIES:
:CUSTOM_ID: moving-around
:END:

Last year I was trying to make a Factorio-like interface where you walk around with a character using your keyboard, even though you're building a base. I decided that it didn't work well. So this year I'm going to try a more conventional mouse-based map scrolling interface. Left mouse drag will scroll the map.

#+begin_export html
<figure>
<img src="blog/1-scrolling-screenshot.png" alt="Screenshot of game map" />
<figcaption>Part 1: scrollable map</figcaption>
</figure>
#+end_export

I used the drag code from [[href:/making-of/draggable/][my draggable object guide]] to move the /camera/ position. But how do I calculate the view from that? The view is a rectangle centered on the camera position.

#+begin_export html
<figure>
<img src="blog/1-scrolling-view.png" alt="Diagram showing the scrollable view area" />
<figcaption>Scrolling calculation: view box</figcaption>
</figure>
#+end_export

The top left of that rectangle is the /offset/ for drawing to the screen. To find the top left, I take the camera position and subtract /half/ the view box size. Then I take the world coordinates of whatever I'm drawing and /subtract/ the offset to the top left corner. If the object is at (50, 35) in the world, and the top left corner of the view box is at (50, 35), then I want to draw the object at (0, 0) on the screen.

#+begin_export html
<figure>
<img src="blog/1-scrolling-offset.png" alt="Diagram showing the offset calculation" />
<figcaption>Scrolling calculation: offset</figcaption>
</figure>
#+end_export

The second thing I wanted to do here was to /constrain/ the camera position to places where the map would be in view. Think about where the view box can be, and then where the camera position can be:

#+begin_export html
<figure>
<img src="blog/1-scrolling-camera-positions.png" alt="Diagram showing where the camera can be placed" />
<figcaption>Scrolling calculation: camera position</figcaption>
</figure>
#+end_export

The camera's position is restricted to a rectangle the size of the map, but shrunk by a /half view box/ at each corner. This will keep the view inside the map region. A little detail: I added a slight margin to this calculation so that you can go outside the map region just a tiny bit. This adds a visual border to show that you're at the edge of the map.

For the other controls, I want to try making something trackpad friendly, requiring only the left button, but then using /keys/ to modify the mouse action. For example, instead of clicking through a menu to select "storage area" and then going into a "storage area marking mode", I might try “hold down ~S~ while dragging a rectangle". This wouldn't require navigating menus. The mode is activated while you hold down the key and the rectangle ends when you release the key. I don't know whether I'll like this until I try it.

* Entity, render, map
:PROPERTIES:
:CUSTOM_ID: entity-render-map
:END:

I did Part 3 (generating a map) first, and then came back to Part 2 (rendering that map, and entities).

Last year, pathfinding turned out to be tricky. Colonists could be building a wall that blocks another colonist's movement. To reduce the scope of the game, I'm going to try simplifying the pathfinding requirements.

1. The player won't dig out rooms or build walls. The rooms already exist in the map, and are unlocked.
2. Pathfinding from room to room can be cheap and precalculated. These paths funnel through the doors.
3. Pathfinding /within/ a room is still tricky, because I want the player to build objects within the room, and those objects would block paths. I need to prohibit building an object that blocks paths across the room. Or … I can let colonists walk over anything, but assign a higher movement cost to them so that they prefer to walk in open areas.
4. Colonists can pass through each other. This simplifies the pathfinding obstacle management. The only obstacles are static objects within rooms.

So I implemented pathfinding, using breadth first search for now, but can switch to A* later. I put 25 colonists into the world and told them to find paths to random locations, then walk there. When they have finished walking, they find another path. This tests the pathfinding system before I have jobs for the colonists.

#+begin_export html
<figure>
  <img src="blog/2-pathfinding-entities.png" alt="Screenshot of colonists in the world" />
  <figcaption>Colonists walking around randomly</figcaption>
</figure>
#+end_export

A side note: Python is /so wonderful/ in how it allows tuples to be used in so many places, including keys for dicts. In JavaScript, an Object can have string keys, and a Map can have object keys, but there's nothing convenient like Python's tuples for storing ~(x, y)~ pairs. C++ and Rust have the convenient tuples too. I miss this when working in JavaScript, and hope that one day [[https://tc39.es/proposal-record-tuple/tutorial/][they get added]], but there seems to be no progress on that proposal.

* Generating a map
:PROPERTIES:
:CUSTOM_ID: generating-a-map
:END:

I liked the left/right nature of the map last year, and I want to do that again. I'll put the wilderness on the left and the dungeon rooms on the right. I reserved the left side of the map for water, then wilderness. Then the rooms begin.

The dungeon rooms will come from the [[href:/x/2321-offgrid/][offgrid algorithm]] that Chris Cox sent me. It's only 20 lines of code. Last year I used thin walls. I think they were neat, especially helping with player-built rooms. I don't have player-built rooms this year. I'll go back to thick walls. Using the offgrid algorithm, I'll generate =left=, =right=, =top=, =bottom= for each room. These are half-open intervals, so ~left <= x < right~ and ~top <= y < bottom~. But I also need to reserve one tile for the thick walls, so I'll use ~left < x < right~ and ~top < y < bottom~.

#+begin_export html
<figure>
  <img src="blog/3-offgrid-map.png" alt="Screenshot" />
  <figcaption>Generated map with water and land on the left, dungeon on the right</figcaption>
</figure>
#+end_export

The next step was to place the walls. There are two parts to this:

1. All tiles within a room are walkable.
2. All tiles to the /left/ of the leftmost room are walkable. This handles the wilderness areas.
3. If there's no leftmost room on a row, use a default border between wilderness and mountain.

The next step after that is doors. I had [[href:/x/1939-planetary-dungeon/#doors][previously written a door algorithm]] that looks at all tiles that have two adjacent room tiles and two adjacent wall tiles. That algorithm would work here. But I can use something similar. Since my rooms are generated from a grid (using the offgrid algorithm), I can use that original grid to find adjacent rooms. For each room, I pick a random tile on the west wall for a door, and I pick a random tile on the north wall for a door, unless the room is in the topmost row. This produces plenty of connectivity, perhaps too much for a traditional adventure mode dungeon, but probably just fine for a colony simulator:

#+begin_export html
<figure>
  <img src="blog/3-map-with-doors.png" alt="Screenshot showing door placement" />
  <figcaption>Generated map doors between rooms, and doors on the left</figcaption>
</figure>
#+end_export

This produces a way to go from the wilderness into the dungeon, and a way to go from dungeon rooms to adjacent rooms.

* Field of view
:PROPERTIES:
:CUSTOM_ID: field-of-view
:END:

The original tutorial calculates which /tiles/ are visible to the player. For this colonist style game I want to compute which /rooms/ and /doors/ are visible to the player. Last year I made everything visible, so I skipped this part. This year, I want the player to unlock rooms as you go through the game, so those rooms won't be visible until you open them up. Here are the visibility rules I came up with:

1. The player can view the wilderness.
1. The player can view unlocked (colonized) rooms.
1. The player can view the outline but not the interior of unlockable rooms.
1. The player cannot view locked rooms that aren't currently unlockable.
1. Unlockable rooms are currently locked and connected to an unlocked room.
1. There can be at most 3 unlockable rooms at a time. I'm hoping to get a "pick one of these 3 cards" vibe here.
1. Once a room is unlocked, it stays unlocked.
1. A door is visible if either of the rooms it is connected to are visible.

Separate from room lock/unlock status, I'm maintaining a ~walkable~ set of tiles. I decided the easiest thing to do was:

1. The ~walkable~ set starts out as the wilderness area, and doors into the wilderness area.
1. Unlocking a room adds the room's tiles and doors to ~walkable~.

#+begin_export html
<figure>
  <img src="blog/4-locked-rooms.png" alt="Screenshot" />
  <figcaption>Some rooms are locked</figcaption>
</figure>
#+end_export

I decided I would have a /UI mode/ that controls how to render and how to interpret mouse events. The key state controls which UI mode I'm in. However, as usual, this simple model didn't quite work cleanly. There were things I needed to deal with like: when pressing  ~R~, I want to highlight the room under the mouse pointer, but the =keydown= event doesn't include the mouse position. That means I need to be storing the mouse position always, even before I need it. Another case is that when pressing ~R~ then ~Shift~ then releasing ~R~, the =keydown= event tells me ='r'= was pressed but the =keyup= event tells me ='R'= was released. There are some edge cases I'm just not going to deal with for this project, but I want to keep it in mind for future projects.

Bug: I noticed that on Firefox/Mac, holding down a key causes the cursor to mostly disappear. Weird. This is not only on my site, but on any site.

Not all rooms are unlockable. Rooms must be /connected/ to an already unlocked room. The way my data structures are written, the easiest way to calculate this was to look at all the doors. A door connecting an unlocked room to a locked room means that locked room is unlockable.

#+begin_export html
<figure>
  <img src="blog/4-unlockable-rooms.png" alt="Screenshot of unlockable rooms" />
  <figcaption>Only some locked rooms are unlockable</figcaption>
</figure>
#+end_export

I also want rooms to have labels, but I need to size the labels so that they fit. I used the [[https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics][TextMetrics]] feature to resize them:

#+begin_export html
<figure>
  <img src="blog/4-room-labels.png" alt="Screenshot of room labels" />
  <figcaption>Rooms have labels, sized to fit</figcaption>
</figure>
#+end_export

The room labels will be "Kitchen", "Dining", "Bedroom", etc. but I haven't implemented room types yet.

* Placing enemies
:PROPERTIES:
:CUSTOM_ID: placing-enemies
:END:

Instead of enemies, I have lots of friendly colonist NPCs. They need to have motivations, jobs, inventory, pathfinding, etc.

I want to place objects within rooms. Should I make colonists build those objects, or should they be built immediately? I think immediate is probably easier to implement, but building objects is a great activity for colonists. Given how this project is too ambitious already, I should do the simpler thing. A further simplification would be to have only one type of object per room, and two types of buffer zones (input and output). Then I can have three keys for those three types of things, instead of having a menu to further select types of things. I want multi-tile objects like chair+table in the dining room, but that complicates things, so I should simplify and stick to single tile objects.

* Combat
:PROPERTIES:
:CUSTOM_ID: combat
:END:

I am considering having a simplified combat as part of the cost of opening up a new room. You'd have to decide how many colonists to send into a new room to defeat the monsters. Send too few, and you might not get the room. What is the downside of sending too many? Maybe they have to rest for a time afterwards, so that reduces your productivity. Is this at all an interesting/fun decision to make? Not sure.

Another option would be to go the Dungeon Keeper or Tower Defense route, where you have to deal with enemies trickling in. As much as I'd love to make a Dungeon Keeper style game, I think I don't even know how to do the basics so that's something to tackle in a future project.

* Interface
:PROPERTIES:
:CUSTOM_ID: interface
:END:

I spent a lot of time [[href:/x/2226-roguelike-dev/#section-7][last year]] looking at other games. One of the biggest problems I see in colony games is that it's hard to understand what's going on and what to do to fix problems. The interface is a big part of that. I am hoping that the focus on room-by-room building rather than tile-by-tile building will let me make the information display less granular. I might also be able to make some decisions more explicit. For example, instead of "workshop output is taken to the nearest stockpile" as a /tile by tile/ decision, I could ask the player to designated a /room's output/ as being another /room/. Then the information display can be a giant arrow from one room to another.

* Items and inventory
:PROPERTIES:
:CUSTOM_ID: items-and-inventory
:END:

Items are generated by resource objects, stored in stockpiles, and transformed by workshop objects.

* Ranged scrolls and targeting
:PROPERTIES:
:CUSTOM_ID: ranged-scrolls-and-targeting
:END:

I don't have ranged scrolls but I expect to have multiple types of building UIs. Rectangular regions, object placement including rotation, what else?

* Saving and loading
:PROPERTIES:
:CUSTOM_ID: saving-and-loading
:END:

I'm not going to attempt this. I think it's great to have, but it's not important to me right now.

* Dungeon levels
:PROPERTIES:
:CUSTOM_ID: dungeon-levels
:END:

In an adventure style game, each dungeon level is standalone, and they increase in difficulty as you progress. In Dwarf Fortress, the levels aren't standalone, but they do increase in difficulty as you dig deeper. But in this game I don't have dungeon levels. Instead, each /room/ could be thought of as a miniature level to conquer.

* Increasing difficulty
:PROPERTIES:
:CUSTOM_ID: increasing-difficulty
:END:

In a normal adventure mode roguelike, difficulty increases as you go /down/ into the dungeon. In this game, I'd like to have the difficulty increase as you go /right/ (east) into the mountain.

* Gearing up
:PROPERTIES:
:CUSTOM_ID: gearing-up
:END:

As much as it might be fun to have gear for the colonists, I am going to skip this. I need to keep the scope down.

* Conclusion
:PROPERTIES:
:UNNUMBERED: t
:CUSTOM_ID: conclusion
:END:

#+begin_export html
<x:footer>
  Created 26 Jun 2023; &#160;
  <!-- hhmts start -->Last modified: 23 Jul 2023<!-- hhmts end -->
</x:footer>
#+end_export
